// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"sync"
	"time"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
	"github.com/altierawr/vstreamer/ent/audiotrack"
	"github.com/altierawr/vstreamer/ent/library"
	"github.com/altierawr/vstreamer/ent/playbackclient"
	"github.com/altierawr/vstreamer/ent/playsession"
	"github.com/altierawr/vstreamer/ent/playsessionmedia"
	"github.com/altierawr/vstreamer/ent/predicate"
	"github.com/altierawr/vstreamer/ent/stream"
	"github.com/altierawr/vstreamer/ent/video"
	"github.com/altierawr/vstreamer/ent/videocodec"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeAudioTrack       = "AudioTrack"
	TypeLibrary          = "Library"
	TypePlaySession      = "PlaySession"
	TypePlaySessionMedia = "PlaySessionMedia"
	TypePlaybackClient   = "PlaybackClient"
	TypeStream           = "Stream"
	TypeVideo            = "Video"
	TypeVideoCodec       = "VideoCodec"
)

// AudioTrackMutation represents an operation that mutates the AudioTrack nodes in the graph.
type AudioTrackMutation struct {
	config
	op             Op
	typ            string
	id             *int
	name           *string
	nr_channels    *int
	addnr_channels *int
	channel_layout *string
	language       *string
	codecs         *[]string
	appendcodecs   []string
	clearedFields  map[string]struct{}
	media          *int
	clearedmedia   bool
	done           bool
	oldValue       func(context.Context) (*AudioTrack, error)
	predicates     []predicate.AudioTrack
}

var _ ent.Mutation = (*AudioTrackMutation)(nil)

// audiotrackOption allows management of the mutation configuration using functional options.
type audiotrackOption func(*AudioTrackMutation)

// newAudioTrackMutation creates new mutation for the AudioTrack entity.
func newAudioTrackMutation(c config, op Op, opts ...audiotrackOption) *AudioTrackMutation {
	m := &AudioTrackMutation{
		config:        c,
		op:            op,
		typ:           TypeAudioTrack,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAudioTrackID sets the ID field of the mutation.
func withAudioTrackID(id int) audiotrackOption {
	return func(m *AudioTrackMutation) {
		var (
			err   error
			once  sync.Once
			value *AudioTrack
		)
		m.oldValue = func(ctx context.Context) (*AudioTrack, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().AudioTrack.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAudioTrack sets the old AudioTrack of the mutation.
func withAudioTrack(node *AudioTrack) audiotrackOption {
	return func(m *AudioTrackMutation) {
		m.oldValue = func(context.Context) (*AudioTrack, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AudioTrackMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AudioTrackMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AudioTrackMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AudioTrackMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().AudioTrack.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *AudioTrackMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *AudioTrackMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the AudioTrack entity.
// If the AudioTrack object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AudioTrackMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *AudioTrackMutation) ResetName() {
	m.name = nil
}

// SetNrChannels sets the "nr_channels" field.
func (m *AudioTrackMutation) SetNrChannels(i int) {
	m.nr_channels = &i
	m.addnr_channels = nil
}

// NrChannels returns the value of the "nr_channels" field in the mutation.
func (m *AudioTrackMutation) NrChannels() (r int, exists bool) {
	v := m.nr_channels
	if v == nil {
		return
	}
	return *v, true
}

// OldNrChannels returns the old "nr_channels" field's value of the AudioTrack entity.
// If the AudioTrack object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AudioTrackMutation) OldNrChannels(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNrChannels is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNrChannels requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNrChannels: %w", err)
	}
	return oldValue.NrChannels, nil
}

// AddNrChannels adds i to the "nr_channels" field.
func (m *AudioTrackMutation) AddNrChannels(i int) {
	if m.addnr_channels != nil {
		*m.addnr_channels += i
	} else {
		m.addnr_channels = &i
	}
}

// AddedNrChannels returns the value that was added to the "nr_channels" field in this mutation.
func (m *AudioTrackMutation) AddedNrChannels() (r int, exists bool) {
	v := m.addnr_channels
	if v == nil {
		return
	}
	return *v, true
}

// ResetNrChannels resets all changes to the "nr_channels" field.
func (m *AudioTrackMutation) ResetNrChannels() {
	m.nr_channels = nil
	m.addnr_channels = nil
}

// SetChannelLayout sets the "channel_layout" field.
func (m *AudioTrackMutation) SetChannelLayout(s string) {
	m.channel_layout = &s
}

// ChannelLayout returns the value of the "channel_layout" field in the mutation.
func (m *AudioTrackMutation) ChannelLayout() (r string, exists bool) {
	v := m.channel_layout
	if v == nil {
		return
	}
	return *v, true
}

// OldChannelLayout returns the old "channel_layout" field's value of the AudioTrack entity.
// If the AudioTrack object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AudioTrackMutation) OldChannelLayout(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldChannelLayout is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldChannelLayout requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldChannelLayout: %w", err)
	}
	return oldValue.ChannelLayout, nil
}

// ResetChannelLayout resets all changes to the "channel_layout" field.
func (m *AudioTrackMutation) ResetChannelLayout() {
	m.channel_layout = nil
}

// SetLanguage sets the "language" field.
func (m *AudioTrackMutation) SetLanguage(s string) {
	m.language = &s
}

// Language returns the value of the "language" field in the mutation.
func (m *AudioTrackMutation) Language() (r string, exists bool) {
	v := m.language
	if v == nil {
		return
	}
	return *v, true
}

// OldLanguage returns the old "language" field's value of the AudioTrack entity.
// If the AudioTrack object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AudioTrackMutation) OldLanguage(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLanguage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLanguage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLanguage: %w", err)
	}
	return oldValue.Language, nil
}

// ClearLanguage clears the value of the "language" field.
func (m *AudioTrackMutation) ClearLanguage() {
	m.language = nil
	m.clearedFields[audiotrack.FieldLanguage] = struct{}{}
}

// LanguageCleared returns if the "language" field was cleared in this mutation.
func (m *AudioTrackMutation) LanguageCleared() bool {
	_, ok := m.clearedFields[audiotrack.FieldLanguage]
	return ok
}

// ResetLanguage resets all changes to the "language" field.
func (m *AudioTrackMutation) ResetLanguage() {
	m.language = nil
	delete(m.clearedFields, audiotrack.FieldLanguage)
}

// SetCodecs sets the "codecs" field.
func (m *AudioTrackMutation) SetCodecs(s []string) {
	m.codecs = &s
	m.appendcodecs = nil
}

// Codecs returns the value of the "codecs" field in the mutation.
func (m *AudioTrackMutation) Codecs() (r []string, exists bool) {
	v := m.codecs
	if v == nil {
		return
	}
	return *v, true
}

// OldCodecs returns the old "codecs" field's value of the AudioTrack entity.
// If the AudioTrack object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AudioTrackMutation) OldCodecs(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCodecs is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCodecs requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCodecs: %w", err)
	}
	return oldValue.Codecs, nil
}

// AppendCodecs adds s to the "codecs" field.
func (m *AudioTrackMutation) AppendCodecs(s []string) {
	m.appendcodecs = append(m.appendcodecs, s...)
}

// AppendedCodecs returns the list of values that were appended to the "codecs" field in this mutation.
func (m *AudioTrackMutation) AppendedCodecs() ([]string, bool) {
	if len(m.appendcodecs) == 0 {
		return nil, false
	}
	return m.appendcodecs, true
}

// ResetCodecs resets all changes to the "codecs" field.
func (m *AudioTrackMutation) ResetCodecs() {
	m.codecs = nil
	m.appendcodecs = nil
}

// SetMediaID sets the "media" edge to the PlaySessionMedia entity by id.
func (m *AudioTrackMutation) SetMediaID(id int) {
	m.media = &id
}

// ClearMedia clears the "media" edge to the PlaySessionMedia entity.
func (m *AudioTrackMutation) ClearMedia() {
	m.clearedmedia = true
}

// MediaCleared reports if the "media" edge to the PlaySessionMedia entity was cleared.
func (m *AudioTrackMutation) MediaCleared() bool {
	return m.clearedmedia
}

// MediaID returns the "media" edge ID in the mutation.
func (m *AudioTrackMutation) MediaID() (id int, exists bool) {
	if m.media != nil {
		return *m.media, true
	}
	return
}

// MediaIDs returns the "media" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// MediaID instead. It exists only for internal usage by the builders.
func (m *AudioTrackMutation) MediaIDs() (ids []int) {
	if id := m.media; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetMedia resets all changes to the "media" edge.
func (m *AudioTrackMutation) ResetMedia() {
	m.media = nil
	m.clearedmedia = false
}

// Where appends a list predicates to the AudioTrackMutation builder.
func (m *AudioTrackMutation) Where(ps ...predicate.AudioTrack) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the AudioTrackMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *AudioTrackMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.AudioTrack, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *AudioTrackMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *AudioTrackMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (AudioTrack).
func (m *AudioTrackMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AudioTrackMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.name != nil {
		fields = append(fields, audiotrack.FieldName)
	}
	if m.nr_channels != nil {
		fields = append(fields, audiotrack.FieldNrChannels)
	}
	if m.channel_layout != nil {
		fields = append(fields, audiotrack.FieldChannelLayout)
	}
	if m.language != nil {
		fields = append(fields, audiotrack.FieldLanguage)
	}
	if m.codecs != nil {
		fields = append(fields, audiotrack.FieldCodecs)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AudioTrackMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case audiotrack.FieldName:
		return m.Name()
	case audiotrack.FieldNrChannels:
		return m.NrChannels()
	case audiotrack.FieldChannelLayout:
		return m.ChannelLayout()
	case audiotrack.FieldLanguage:
		return m.Language()
	case audiotrack.FieldCodecs:
		return m.Codecs()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AudioTrackMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case audiotrack.FieldName:
		return m.OldName(ctx)
	case audiotrack.FieldNrChannels:
		return m.OldNrChannels(ctx)
	case audiotrack.FieldChannelLayout:
		return m.OldChannelLayout(ctx)
	case audiotrack.FieldLanguage:
		return m.OldLanguage(ctx)
	case audiotrack.FieldCodecs:
		return m.OldCodecs(ctx)
	}
	return nil, fmt.Errorf("unknown AudioTrack field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AudioTrackMutation) SetField(name string, value ent.Value) error {
	switch name {
	case audiotrack.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case audiotrack.FieldNrChannels:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNrChannels(v)
		return nil
	case audiotrack.FieldChannelLayout:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetChannelLayout(v)
		return nil
	case audiotrack.FieldLanguage:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLanguage(v)
		return nil
	case audiotrack.FieldCodecs:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCodecs(v)
		return nil
	}
	return fmt.Errorf("unknown AudioTrack field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AudioTrackMutation) AddedFields() []string {
	var fields []string
	if m.addnr_channels != nil {
		fields = append(fields, audiotrack.FieldNrChannels)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AudioTrackMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case audiotrack.FieldNrChannels:
		return m.AddedNrChannels()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AudioTrackMutation) AddField(name string, value ent.Value) error {
	switch name {
	case audiotrack.FieldNrChannels:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddNrChannels(v)
		return nil
	}
	return fmt.Errorf("unknown AudioTrack numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AudioTrackMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(audiotrack.FieldLanguage) {
		fields = append(fields, audiotrack.FieldLanguage)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AudioTrackMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AudioTrackMutation) ClearField(name string) error {
	switch name {
	case audiotrack.FieldLanguage:
		m.ClearLanguage()
		return nil
	}
	return fmt.Errorf("unknown AudioTrack nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AudioTrackMutation) ResetField(name string) error {
	switch name {
	case audiotrack.FieldName:
		m.ResetName()
		return nil
	case audiotrack.FieldNrChannels:
		m.ResetNrChannels()
		return nil
	case audiotrack.FieldChannelLayout:
		m.ResetChannelLayout()
		return nil
	case audiotrack.FieldLanguage:
		m.ResetLanguage()
		return nil
	case audiotrack.FieldCodecs:
		m.ResetCodecs()
		return nil
	}
	return fmt.Errorf("unknown AudioTrack field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AudioTrackMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.media != nil {
		edges = append(edges, audiotrack.EdgeMedia)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AudioTrackMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case audiotrack.EdgeMedia:
		if id := m.media; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AudioTrackMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AudioTrackMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AudioTrackMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedmedia {
		edges = append(edges, audiotrack.EdgeMedia)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AudioTrackMutation) EdgeCleared(name string) bool {
	switch name {
	case audiotrack.EdgeMedia:
		return m.clearedmedia
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AudioTrackMutation) ClearEdge(name string) error {
	switch name {
	case audiotrack.EdgeMedia:
		m.ClearMedia()
		return nil
	}
	return fmt.Errorf("unknown AudioTrack unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AudioTrackMutation) ResetEdge(name string) error {
	switch name {
	case audiotrack.EdgeMedia:
		m.ResetMedia()
		return nil
	}
	return fmt.Errorf("unknown AudioTrack edge %s", name)
}

// LibraryMutation represents an operation that mutates the Library nodes in the graph.
type LibraryMutation struct {
	config
	op            Op
	typ           string
	id            *int
	_path         *string
	created_at    *time.Time
	clearedFields map[string]struct{}
	videos        map[int]struct{}
	removedvideos map[int]struct{}
	clearedvideos bool
	done          bool
	oldValue      func(context.Context) (*Library, error)
	predicates    []predicate.Library
}

var _ ent.Mutation = (*LibraryMutation)(nil)

// libraryOption allows management of the mutation configuration using functional options.
type libraryOption func(*LibraryMutation)

// newLibraryMutation creates new mutation for the Library entity.
func newLibraryMutation(c config, op Op, opts ...libraryOption) *LibraryMutation {
	m := &LibraryMutation{
		config:        c,
		op:            op,
		typ:           TypeLibrary,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withLibraryID sets the ID field of the mutation.
func withLibraryID(id int) libraryOption {
	return func(m *LibraryMutation) {
		var (
			err   error
			once  sync.Once
			value *Library
		)
		m.oldValue = func(ctx context.Context) (*Library, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Library.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withLibrary sets the old Library of the mutation.
func withLibrary(node *Library) libraryOption {
	return func(m *LibraryMutation) {
		m.oldValue = func(context.Context) (*Library, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m LibraryMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m LibraryMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *LibraryMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *LibraryMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Library.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetPath sets the "path" field.
func (m *LibraryMutation) SetPath(s string) {
	m._path = &s
}

// Path returns the value of the "path" field in the mutation.
func (m *LibraryMutation) Path() (r string, exists bool) {
	v := m._path
	if v == nil {
		return
	}
	return *v, true
}

// OldPath returns the old "path" field's value of the Library entity.
// If the Library object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LibraryMutation) OldPath(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPath is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPath requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPath: %w", err)
	}
	return oldValue.Path, nil
}

// ResetPath resets all changes to the "path" field.
func (m *LibraryMutation) ResetPath() {
	m._path = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *LibraryMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *LibraryMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Library entity.
// If the Library object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LibraryMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *LibraryMutation) ResetCreatedAt() {
	m.created_at = nil
}

// AddVideoIDs adds the "videos" edge to the Video entity by ids.
func (m *LibraryMutation) AddVideoIDs(ids ...int) {
	if m.videos == nil {
		m.videos = make(map[int]struct{})
	}
	for i := range ids {
		m.videos[ids[i]] = struct{}{}
	}
}

// ClearVideos clears the "videos" edge to the Video entity.
func (m *LibraryMutation) ClearVideos() {
	m.clearedvideos = true
}

// VideosCleared reports if the "videos" edge to the Video entity was cleared.
func (m *LibraryMutation) VideosCleared() bool {
	return m.clearedvideos
}

// RemoveVideoIDs removes the "videos" edge to the Video entity by IDs.
func (m *LibraryMutation) RemoveVideoIDs(ids ...int) {
	if m.removedvideos == nil {
		m.removedvideos = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.videos, ids[i])
		m.removedvideos[ids[i]] = struct{}{}
	}
}

// RemovedVideos returns the removed IDs of the "videos" edge to the Video entity.
func (m *LibraryMutation) RemovedVideosIDs() (ids []int) {
	for id := range m.removedvideos {
		ids = append(ids, id)
	}
	return
}

// VideosIDs returns the "videos" edge IDs in the mutation.
func (m *LibraryMutation) VideosIDs() (ids []int) {
	for id := range m.videos {
		ids = append(ids, id)
	}
	return
}

// ResetVideos resets all changes to the "videos" edge.
func (m *LibraryMutation) ResetVideos() {
	m.videos = nil
	m.clearedvideos = false
	m.removedvideos = nil
}

// Where appends a list predicates to the LibraryMutation builder.
func (m *LibraryMutation) Where(ps ...predicate.Library) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the LibraryMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *LibraryMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Library, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *LibraryMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *LibraryMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Library).
func (m *LibraryMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *LibraryMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m._path != nil {
		fields = append(fields, library.FieldPath)
	}
	if m.created_at != nil {
		fields = append(fields, library.FieldCreatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *LibraryMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case library.FieldPath:
		return m.Path()
	case library.FieldCreatedAt:
		return m.CreatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *LibraryMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case library.FieldPath:
		return m.OldPath(ctx)
	case library.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Library field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *LibraryMutation) SetField(name string, value ent.Value) error {
	switch name {
	case library.FieldPath:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPath(v)
		return nil
	case library.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Library field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *LibraryMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *LibraryMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *LibraryMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Library numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *LibraryMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *LibraryMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *LibraryMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Library nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *LibraryMutation) ResetField(name string) error {
	switch name {
	case library.FieldPath:
		m.ResetPath()
		return nil
	case library.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	}
	return fmt.Errorf("unknown Library field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *LibraryMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.videos != nil {
		edges = append(edges, library.EdgeVideos)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *LibraryMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case library.EdgeVideos:
		ids := make([]ent.Value, 0, len(m.videos))
		for id := range m.videos {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *LibraryMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedvideos != nil {
		edges = append(edges, library.EdgeVideos)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *LibraryMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case library.EdgeVideos:
		ids := make([]ent.Value, 0, len(m.removedvideos))
		for id := range m.removedvideos {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *LibraryMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedvideos {
		edges = append(edges, library.EdgeVideos)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *LibraryMutation) EdgeCleared(name string) bool {
	switch name {
	case library.EdgeVideos:
		return m.clearedvideos
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *LibraryMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Library unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *LibraryMutation) ResetEdge(name string) error {
	switch name {
	case library.EdgeVideos:
		m.ResetVideos()
		return nil
	}
	return fmt.Errorf("unknown Library edge %s", name)
}

// PlaySessionMutation represents an operation that mutates the PlaySession nodes in the graph.
type PlaySessionMutation struct {
	config
	op              Op
	typ             string
	id              *int
	current_time    *int
	addcurrent_time *int
	state           *playsession.State
	clearedFields   map[string]struct{}
	clients         map[int]struct{}
	removedclients  map[int]struct{}
	clearedclients  bool
	media           *int
	clearedmedia    bool
	done            bool
	oldValue        func(context.Context) (*PlaySession, error)
	predicates      []predicate.PlaySession
}

var _ ent.Mutation = (*PlaySessionMutation)(nil)

// playsessionOption allows management of the mutation configuration using functional options.
type playsessionOption func(*PlaySessionMutation)

// newPlaySessionMutation creates new mutation for the PlaySession entity.
func newPlaySessionMutation(c config, op Op, opts ...playsessionOption) *PlaySessionMutation {
	m := &PlaySessionMutation{
		config:        c,
		op:            op,
		typ:           TypePlaySession,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPlaySessionID sets the ID field of the mutation.
func withPlaySessionID(id int) playsessionOption {
	return func(m *PlaySessionMutation) {
		var (
			err   error
			once  sync.Once
			value *PlaySession
		)
		m.oldValue = func(ctx context.Context) (*PlaySession, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().PlaySession.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPlaySession sets the old PlaySession of the mutation.
func withPlaySession(node *PlaySession) playsessionOption {
	return func(m *PlaySessionMutation) {
		m.oldValue = func(context.Context) (*PlaySession, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PlaySessionMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PlaySessionMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *PlaySessionMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *PlaySessionMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().PlaySession.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCurrentTime sets the "current_time" field.
func (m *PlaySessionMutation) SetCurrentTime(i int) {
	m.current_time = &i
	m.addcurrent_time = nil
}

// CurrentTime returns the value of the "current_time" field in the mutation.
func (m *PlaySessionMutation) CurrentTime() (r int, exists bool) {
	v := m.current_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCurrentTime returns the old "current_time" field's value of the PlaySession entity.
// If the PlaySession object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlaySessionMutation) OldCurrentTime(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCurrentTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCurrentTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCurrentTime: %w", err)
	}
	return oldValue.CurrentTime, nil
}

// AddCurrentTime adds i to the "current_time" field.
func (m *PlaySessionMutation) AddCurrentTime(i int) {
	if m.addcurrent_time != nil {
		*m.addcurrent_time += i
	} else {
		m.addcurrent_time = &i
	}
}

// AddedCurrentTime returns the value that was added to the "current_time" field in this mutation.
func (m *PlaySessionMutation) AddedCurrentTime() (r int, exists bool) {
	v := m.addcurrent_time
	if v == nil {
		return
	}
	return *v, true
}

// ClearCurrentTime clears the value of the "current_time" field.
func (m *PlaySessionMutation) ClearCurrentTime() {
	m.current_time = nil
	m.addcurrent_time = nil
	m.clearedFields[playsession.FieldCurrentTime] = struct{}{}
}

// CurrentTimeCleared returns if the "current_time" field was cleared in this mutation.
func (m *PlaySessionMutation) CurrentTimeCleared() bool {
	_, ok := m.clearedFields[playsession.FieldCurrentTime]
	return ok
}

// ResetCurrentTime resets all changes to the "current_time" field.
func (m *PlaySessionMutation) ResetCurrentTime() {
	m.current_time = nil
	m.addcurrent_time = nil
	delete(m.clearedFields, playsession.FieldCurrentTime)
}

// SetState sets the "state" field.
func (m *PlaySessionMutation) SetState(pl playsession.State) {
	m.state = &pl
}

// State returns the value of the "state" field in the mutation.
func (m *PlaySessionMutation) State() (r playsession.State, exists bool) {
	v := m.state
	if v == nil {
		return
	}
	return *v, true
}

// OldState returns the old "state" field's value of the PlaySession entity.
// If the PlaySession object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlaySessionMutation) OldState(ctx context.Context) (v playsession.State, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldState is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldState requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldState: %w", err)
	}
	return oldValue.State, nil
}

// ResetState resets all changes to the "state" field.
func (m *PlaySessionMutation) ResetState() {
	m.state = nil
}

// AddClientIDs adds the "clients" edge to the PlaybackClient entity by ids.
func (m *PlaySessionMutation) AddClientIDs(ids ...int) {
	if m.clients == nil {
		m.clients = make(map[int]struct{})
	}
	for i := range ids {
		m.clients[ids[i]] = struct{}{}
	}
}

// ClearClients clears the "clients" edge to the PlaybackClient entity.
func (m *PlaySessionMutation) ClearClients() {
	m.clearedclients = true
}

// ClientsCleared reports if the "clients" edge to the PlaybackClient entity was cleared.
func (m *PlaySessionMutation) ClientsCleared() bool {
	return m.clearedclients
}

// RemoveClientIDs removes the "clients" edge to the PlaybackClient entity by IDs.
func (m *PlaySessionMutation) RemoveClientIDs(ids ...int) {
	if m.removedclients == nil {
		m.removedclients = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.clients, ids[i])
		m.removedclients[ids[i]] = struct{}{}
	}
}

// RemovedClients returns the removed IDs of the "clients" edge to the PlaybackClient entity.
func (m *PlaySessionMutation) RemovedClientsIDs() (ids []int) {
	for id := range m.removedclients {
		ids = append(ids, id)
	}
	return
}

// ClientsIDs returns the "clients" edge IDs in the mutation.
func (m *PlaySessionMutation) ClientsIDs() (ids []int) {
	for id := range m.clients {
		ids = append(ids, id)
	}
	return
}

// ResetClients resets all changes to the "clients" edge.
func (m *PlaySessionMutation) ResetClients() {
	m.clients = nil
	m.clearedclients = false
	m.removedclients = nil
}

// SetMediaID sets the "media" edge to the PlaySessionMedia entity by id.
func (m *PlaySessionMutation) SetMediaID(id int) {
	m.media = &id
}

// ClearMedia clears the "media" edge to the PlaySessionMedia entity.
func (m *PlaySessionMutation) ClearMedia() {
	m.clearedmedia = true
}

// MediaCleared reports if the "media" edge to the PlaySessionMedia entity was cleared.
func (m *PlaySessionMutation) MediaCleared() bool {
	return m.clearedmedia
}

// MediaID returns the "media" edge ID in the mutation.
func (m *PlaySessionMutation) MediaID() (id int, exists bool) {
	if m.media != nil {
		return *m.media, true
	}
	return
}

// MediaIDs returns the "media" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// MediaID instead. It exists only for internal usage by the builders.
func (m *PlaySessionMutation) MediaIDs() (ids []int) {
	if id := m.media; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetMedia resets all changes to the "media" edge.
func (m *PlaySessionMutation) ResetMedia() {
	m.media = nil
	m.clearedmedia = false
}

// Where appends a list predicates to the PlaySessionMutation builder.
func (m *PlaySessionMutation) Where(ps ...predicate.PlaySession) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the PlaySessionMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *PlaySessionMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.PlaySession, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *PlaySessionMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *PlaySessionMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (PlaySession).
func (m *PlaySessionMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PlaySessionMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m.current_time != nil {
		fields = append(fields, playsession.FieldCurrentTime)
	}
	if m.state != nil {
		fields = append(fields, playsession.FieldState)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PlaySessionMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case playsession.FieldCurrentTime:
		return m.CurrentTime()
	case playsession.FieldState:
		return m.State()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PlaySessionMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case playsession.FieldCurrentTime:
		return m.OldCurrentTime(ctx)
	case playsession.FieldState:
		return m.OldState(ctx)
	}
	return nil, fmt.Errorf("unknown PlaySession field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PlaySessionMutation) SetField(name string, value ent.Value) error {
	switch name {
	case playsession.FieldCurrentTime:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCurrentTime(v)
		return nil
	case playsession.FieldState:
		v, ok := value.(playsession.State)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetState(v)
		return nil
	}
	return fmt.Errorf("unknown PlaySession field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PlaySessionMutation) AddedFields() []string {
	var fields []string
	if m.addcurrent_time != nil {
		fields = append(fields, playsession.FieldCurrentTime)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PlaySessionMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case playsession.FieldCurrentTime:
		return m.AddedCurrentTime()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PlaySessionMutation) AddField(name string, value ent.Value) error {
	switch name {
	case playsession.FieldCurrentTime:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCurrentTime(v)
		return nil
	}
	return fmt.Errorf("unknown PlaySession numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PlaySessionMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(playsession.FieldCurrentTime) {
		fields = append(fields, playsession.FieldCurrentTime)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PlaySessionMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PlaySessionMutation) ClearField(name string) error {
	switch name {
	case playsession.FieldCurrentTime:
		m.ClearCurrentTime()
		return nil
	}
	return fmt.Errorf("unknown PlaySession nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PlaySessionMutation) ResetField(name string) error {
	switch name {
	case playsession.FieldCurrentTime:
		m.ResetCurrentTime()
		return nil
	case playsession.FieldState:
		m.ResetState()
		return nil
	}
	return fmt.Errorf("unknown PlaySession field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PlaySessionMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clients != nil {
		edges = append(edges, playsession.EdgeClients)
	}
	if m.media != nil {
		edges = append(edges, playsession.EdgeMedia)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PlaySessionMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case playsession.EdgeClients:
		ids := make([]ent.Value, 0, len(m.clients))
		for id := range m.clients {
			ids = append(ids, id)
		}
		return ids
	case playsession.EdgeMedia:
		if id := m.media; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PlaySessionMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedclients != nil {
		edges = append(edges, playsession.EdgeClients)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PlaySessionMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case playsession.EdgeClients:
		ids := make([]ent.Value, 0, len(m.removedclients))
		for id := range m.removedclients {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PlaySessionMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedclients {
		edges = append(edges, playsession.EdgeClients)
	}
	if m.clearedmedia {
		edges = append(edges, playsession.EdgeMedia)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PlaySessionMutation) EdgeCleared(name string) bool {
	switch name {
	case playsession.EdgeClients:
		return m.clearedclients
	case playsession.EdgeMedia:
		return m.clearedmedia
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PlaySessionMutation) ClearEdge(name string) error {
	switch name {
	case playsession.EdgeMedia:
		m.ClearMedia()
		return nil
	}
	return fmt.Errorf("unknown PlaySession unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PlaySessionMutation) ResetEdge(name string) error {
	switch name {
	case playsession.EdgeClients:
		m.ResetClients()
		return nil
	case playsession.EdgeMedia:
		m.ResetMedia()
		return nil
	}
	return fmt.Errorf("unknown PlaySession edge %s", name)
}

// PlaySessionMediaMutation represents an operation that mutates the PlaySessionMedia nodes in the graph.
type PlaySessionMediaMutation struct {
	config
	op                  Op
	typ                 string
	id                  *int
	resolutions         *[]string
	appendresolutions   []string
	clearedFields       map[string]struct{}
	audio_tracks        map[int]struct{}
	removedaudio_tracks map[int]struct{}
	clearedaudio_tracks bool
	video               *int
	clearedvideo        bool
	session             *int
	clearedsession      bool
	video_codecs        map[int]struct{}
	removedvideo_codecs map[int]struct{}
	clearedvideo_codecs bool
	done                bool
	oldValue            func(context.Context) (*PlaySessionMedia, error)
	predicates          []predicate.PlaySessionMedia
}

var _ ent.Mutation = (*PlaySessionMediaMutation)(nil)

// playsessionmediaOption allows management of the mutation configuration using functional options.
type playsessionmediaOption func(*PlaySessionMediaMutation)

// newPlaySessionMediaMutation creates new mutation for the PlaySessionMedia entity.
func newPlaySessionMediaMutation(c config, op Op, opts ...playsessionmediaOption) *PlaySessionMediaMutation {
	m := &PlaySessionMediaMutation{
		config:        c,
		op:            op,
		typ:           TypePlaySessionMedia,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPlaySessionMediaID sets the ID field of the mutation.
func withPlaySessionMediaID(id int) playsessionmediaOption {
	return func(m *PlaySessionMediaMutation) {
		var (
			err   error
			once  sync.Once
			value *PlaySessionMedia
		)
		m.oldValue = func(ctx context.Context) (*PlaySessionMedia, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().PlaySessionMedia.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPlaySessionMedia sets the old PlaySessionMedia of the mutation.
func withPlaySessionMedia(node *PlaySessionMedia) playsessionmediaOption {
	return func(m *PlaySessionMediaMutation) {
		m.oldValue = func(context.Context) (*PlaySessionMedia, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PlaySessionMediaMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PlaySessionMediaMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *PlaySessionMediaMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *PlaySessionMediaMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().PlaySessionMedia.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetResolutions sets the "resolutions" field.
func (m *PlaySessionMediaMutation) SetResolutions(s []string) {
	m.resolutions = &s
	m.appendresolutions = nil
}

// Resolutions returns the value of the "resolutions" field in the mutation.
func (m *PlaySessionMediaMutation) Resolutions() (r []string, exists bool) {
	v := m.resolutions
	if v == nil {
		return
	}
	return *v, true
}

// OldResolutions returns the old "resolutions" field's value of the PlaySessionMedia entity.
// If the PlaySessionMedia object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlaySessionMediaMutation) OldResolutions(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldResolutions is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldResolutions requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldResolutions: %w", err)
	}
	return oldValue.Resolutions, nil
}

// AppendResolutions adds s to the "resolutions" field.
func (m *PlaySessionMediaMutation) AppendResolutions(s []string) {
	m.appendresolutions = append(m.appendresolutions, s...)
}

// AppendedResolutions returns the list of values that were appended to the "resolutions" field in this mutation.
func (m *PlaySessionMediaMutation) AppendedResolutions() ([]string, bool) {
	if len(m.appendresolutions) == 0 {
		return nil, false
	}
	return m.appendresolutions, true
}

// ResetResolutions resets all changes to the "resolutions" field.
func (m *PlaySessionMediaMutation) ResetResolutions() {
	m.resolutions = nil
	m.appendresolutions = nil
}

// AddAudioTrackIDs adds the "audio_tracks" edge to the AudioTrack entity by ids.
func (m *PlaySessionMediaMutation) AddAudioTrackIDs(ids ...int) {
	if m.audio_tracks == nil {
		m.audio_tracks = make(map[int]struct{})
	}
	for i := range ids {
		m.audio_tracks[ids[i]] = struct{}{}
	}
}

// ClearAudioTracks clears the "audio_tracks" edge to the AudioTrack entity.
func (m *PlaySessionMediaMutation) ClearAudioTracks() {
	m.clearedaudio_tracks = true
}

// AudioTracksCleared reports if the "audio_tracks" edge to the AudioTrack entity was cleared.
func (m *PlaySessionMediaMutation) AudioTracksCleared() bool {
	return m.clearedaudio_tracks
}

// RemoveAudioTrackIDs removes the "audio_tracks" edge to the AudioTrack entity by IDs.
func (m *PlaySessionMediaMutation) RemoveAudioTrackIDs(ids ...int) {
	if m.removedaudio_tracks == nil {
		m.removedaudio_tracks = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.audio_tracks, ids[i])
		m.removedaudio_tracks[ids[i]] = struct{}{}
	}
}

// RemovedAudioTracks returns the removed IDs of the "audio_tracks" edge to the AudioTrack entity.
func (m *PlaySessionMediaMutation) RemovedAudioTracksIDs() (ids []int) {
	for id := range m.removedaudio_tracks {
		ids = append(ids, id)
	}
	return
}

// AudioTracksIDs returns the "audio_tracks" edge IDs in the mutation.
func (m *PlaySessionMediaMutation) AudioTracksIDs() (ids []int) {
	for id := range m.audio_tracks {
		ids = append(ids, id)
	}
	return
}

// ResetAudioTracks resets all changes to the "audio_tracks" edge.
func (m *PlaySessionMediaMutation) ResetAudioTracks() {
	m.audio_tracks = nil
	m.clearedaudio_tracks = false
	m.removedaudio_tracks = nil
}

// SetVideoID sets the "video" edge to the Video entity by id.
func (m *PlaySessionMediaMutation) SetVideoID(id int) {
	m.video = &id
}

// ClearVideo clears the "video" edge to the Video entity.
func (m *PlaySessionMediaMutation) ClearVideo() {
	m.clearedvideo = true
}

// VideoCleared reports if the "video" edge to the Video entity was cleared.
func (m *PlaySessionMediaMutation) VideoCleared() bool {
	return m.clearedvideo
}

// VideoID returns the "video" edge ID in the mutation.
func (m *PlaySessionMediaMutation) VideoID() (id int, exists bool) {
	if m.video != nil {
		return *m.video, true
	}
	return
}

// VideoIDs returns the "video" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// VideoID instead. It exists only for internal usage by the builders.
func (m *PlaySessionMediaMutation) VideoIDs() (ids []int) {
	if id := m.video; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetVideo resets all changes to the "video" edge.
func (m *PlaySessionMediaMutation) ResetVideo() {
	m.video = nil
	m.clearedvideo = false
}

// SetSessionID sets the "session" edge to the PlaySession entity by id.
func (m *PlaySessionMediaMutation) SetSessionID(id int) {
	m.session = &id
}

// ClearSession clears the "session" edge to the PlaySession entity.
func (m *PlaySessionMediaMutation) ClearSession() {
	m.clearedsession = true
}

// SessionCleared reports if the "session" edge to the PlaySession entity was cleared.
func (m *PlaySessionMediaMutation) SessionCleared() bool {
	return m.clearedsession
}

// SessionID returns the "session" edge ID in the mutation.
func (m *PlaySessionMediaMutation) SessionID() (id int, exists bool) {
	if m.session != nil {
		return *m.session, true
	}
	return
}

// SessionIDs returns the "session" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// SessionID instead. It exists only for internal usage by the builders.
func (m *PlaySessionMediaMutation) SessionIDs() (ids []int) {
	if id := m.session; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetSession resets all changes to the "session" edge.
func (m *PlaySessionMediaMutation) ResetSession() {
	m.session = nil
	m.clearedsession = false
}

// AddVideoCodecIDs adds the "video_codecs" edge to the VideoCodec entity by ids.
func (m *PlaySessionMediaMutation) AddVideoCodecIDs(ids ...int) {
	if m.video_codecs == nil {
		m.video_codecs = make(map[int]struct{})
	}
	for i := range ids {
		m.video_codecs[ids[i]] = struct{}{}
	}
}

// ClearVideoCodecs clears the "video_codecs" edge to the VideoCodec entity.
func (m *PlaySessionMediaMutation) ClearVideoCodecs() {
	m.clearedvideo_codecs = true
}

// VideoCodecsCleared reports if the "video_codecs" edge to the VideoCodec entity was cleared.
func (m *PlaySessionMediaMutation) VideoCodecsCleared() bool {
	return m.clearedvideo_codecs
}

// RemoveVideoCodecIDs removes the "video_codecs" edge to the VideoCodec entity by IDs.
func (m *PlaySessionMediaMutation) RemoveVideoCodecIDs(ids ...int) {
	if m.removedvideo_codecs == nil {
		m.removedvideo_codecs = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.video_codecs, ids[i])
		m.removedvideo_codecs[ids[i]] = struct{}{}
	}
}

// RemovedVideoCodecs returns the removed IDs of the "video_codecs" edge to the VideoCodec entity.
func (m *PlaySessionMediaMutation) RemovedVideoCodecsIDs() (ids []int) {
	for id := range m.removedvideo_codecs {
		ids = append(ids, id)
	}
	return
}

// VideoCodecsIDs returns the "video_codecs" edge IDs in the mutation.
func (m *PlaySessionMediaMutation) VideoCodecsIDs() (ids []int) {
	for id := range m.video_codecs {
		ids = append(ids, id)
	}
	return
}

// ResetVideoCodecs resets all changes to the "video_codecs" edge.
func (m *PlaySessionMediaMutation) ResetVideoCodecs() {
	m.video_codecs = nil
	m.clearedvideo_codecs = false
	m.removedvideo_codecs = nil
}

// Where appends a list predicates to the PlaySessionMediaMutation builder.
func (m *PlaySessionMediaMutation) Where(ps ...predicate.PlaySessionMedia) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the PlaySessionMediaMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *PlaySessionMediaMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.PlaySessionMedia, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *PlaySessionMediaMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *PlaySessionMediaMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (PlaySessionMedia).
func (m *PlaySessionMediaMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PlaySessionMediaMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.resolutions != nil {
		fields = append(fields, playsessionmedia.FieldResolutions)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PlaySessionMediaMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case playsessionmedia.FieldResolutions:
		return m.Resolutions()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PlaySessionMediaMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case playsessionmedia.FieldResolutions:
		return m.OldResolutions(ctx)
	}
	return nil, fmt.Errorf("unknown PlaySessionMedia field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PlaySessionMediaMutation) SetField(name string, value ent.Value) error {
	switch name {
	case playsessionmedia.FieldResolutions:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetResolutions(v)
		return nil
	}
	return fmt.Errorf("unknown PlaySessionMedia field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PlaySessionMediaMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PlaySessionMediaMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PlaySessionMediaMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown PlaySessionMedia numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PlaySessionMediaMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PlaySessionMediaMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PlaySessionMediaMutation) ClearField(name string) error {
	return fmt.Errorf("unknown PlaySessionMedia nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PlaySessionMediaMutation) ResetField(name string) error {
	switch name {
	case playsessionmedia.FieldResolutions:
		m.ResetResolutions()
		return nil
	}
	return fmt.Errorf("unknown PlaySessionMedia field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PlaySessionMediaMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.audio_tracks != nil {
		edges = append(edges, playsessionmedia.EdgeAudioTracks)
	}
	if m.video != nil {
		edges = append(edges, playsessionmedia.EdgeVideo)
	}
	if m.session != nil {
		edges = append(edges, playsessionmedia.EdgeSession)
	}
	if m.video_codecs != nil {
		edges = append(edges, playsessionmedia.EdgeVideoCodecs)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PlaySessionMediaMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case playsessionmedia.EdgeAudioTracks:
		ids := make([]ent.Value, 0, len(m.audio_tracks))
		for id := range m.audio_tracks {
			ids = append(ids, id)
		}
		return ids
	case playsessionmedia.EdgeVideo:
		if id := m.video; id != nil {
			return []ent.Value{*id}
		}
	case playsessionmedia.EdgeSession:
		if id := m.session; id != nil {
			return []ent.Value{*id}
		}
	case playsessionmedia.EdgeVideoCodecs:
		ids := make([]ent.Value, 0, len(m.video_codecs))
		for id := range m.video_codecs {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PlaySessionMediaMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	if m.removedaudio_tracks != nil {
		edges = append(edges, playsessionmedia.EdgeAudioTracks)
	}
	if m.removedvideo_codecs != nil {
		edges = append(edges, playsessionmedia.EdgeVideoCodecs)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PlaySessionMediaMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case playsessionmedia.EdgeAudioTracks:
		ids := make([]ent.Value, 0, len(m.removedaudio_tracks))
		for id := range m.removedaudio_tracks {
			ids = append(ids, id)
		}
		return ids
	case playsessionmedia.EdgeVideoCodecs:
		ids := make([]ent.Value, 0, len(m.removedvideo_codecs))
		for id := range m.removedvideo_codecs {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PlaySessionMediaMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.clearedaudio_tracks {
		edges = append(edges, playsessionmedia.EdgeAudioTracks)
	}
	if m.clearedvideo {
		edges = append(edges, playsessionmedia.EdgeVideo)
	}
	if m.clearedsession {
		edges = append(edges, playsessionmedia.EdgeSession)
	}
	if m.clearedvideo_codecs {
		edges = append(edges, playsessionmedia.EdgeVideoCodecs)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PlaySessionMediaMutation) EdgeCleared(name string) bool {
	switch name {
	case playsessionmedia.EdgeAudioTracks:
		return m.clearedaudio_tracks
	case playsessionmedia.EdgeVideo:
		return m.clearedvideo
	case playsessionmedia.EdgeSession:
		return m.clearedsession
	case playsessionmedia.EdgeVideoCodecs:
		return m.clearedvideo_codecs
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PlaySessionMediaMutation) ClearEdge(name string) error {
	switch name {
	case playsessionmedia.EdgeVideo:
		m.ClearVideo()
		return nil
	case playsessionmedia.EdgeSession:
		m.ClearSession()
		return nil
	}
	return fmt.Errorf("unknown PlaySessionMedia unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PlaySessionMediaMutation) ResetEdge(name string) error {
	switch name {
	case playsessionmedia.EdgeAudioTracks:
		m.ResetAudioTracks()
		return nil
	case playsessionmedia.EdgeVideo:
		m.ResetVideo()
		return nil
	case playsessionmedia.EdgeSession:
		m.ResetSession()
		return nil
	case playsessionmedia.EdgeVideoCodecs:
		m.ResetVideoCodecs()
		return nil
	}
	return fmt.Errorf("unknown PlaySessionMedia edge %s", name)
}

// PlaybackClientMutation represents an operation that mutates the PlaybackClient nodes in the graph.
type PlaybackClientMutation struct {
	config
	op             Op
	typ            string
	id             *int
	is_buffered    *bool
	clearedFields  map[string]struct{}
	session        *int
	clearedsession bool
	done           bool
	oldValue       func(context.Context) (*PlaybackClient, error)
	predicates     []predicate.PlaybackClient
}

var _ ent.Mutation = (*PlaybackClientMutation)(nil)

// playbackclientOption allows management of the mutation configuration using functional options.
type playbackclientOption func(*PlaybackClientMutation)

// newPlaybackClientMutation creates new mutation for the PlaybackClient entity.
func newPlaybackClientMutation(c config, op Op, opts ...playbackclientOption) *PlaybackClientMutation {
	m := &PlaybackClientMutation{
		config:        c,
		op:            op,
		typ:           TypePlaybackClient,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPlaybackClientID sets the ID field of the mutation.
func withPlaybackClientID(id int) playbackclientOption {
	return func(m *PlaybackClientMutation) {
		var (
			err   error
			once  sync.Once
			value *PlaybackClient
		)
		m.oldValue = func(ctx context.Context) (*PlaybackClient, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().PlaybackClient.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPlaybackClient sets the old PlaybackClient of the mutation.
func withPlaybackClient(node *PlaybackClient) playbackclientOption {
	return func(m *PlaybackClientMutation) {
		m.oldValue = func(context.Context) (*PlaybackClient, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PlaybackClientMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PlaybackClientMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *PlaybackClientMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *PlaybackClientMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().PlaybackClient.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetIsBuffered sets the "is_buffered" field.
func (m *PlaybackClientMutation) SetIsBuffered(b bool) {
	m.is_buffered = &b
}

// IsBuffered returns the value of the "is_buffered" field in the mutation.
func (m *PlaybackClientMutation) IsBuffered() (r bool, exists bool) {
	v := m.is_buffered
	if v == nil {
		return
	}
	return *v, true
}

// OldIsBuffered returns the old "is_buffered" field's value of the PlaybackClient entity.
// If the PlaybackClient object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlaybackClientMutation) OldIsBuffered(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsBuffered is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsBuffered requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsBuffered: %w", err)
	}
	return oldValue.IsBuffered, nil
}

// ResetIsBuffered resets all changes to the "is_buffered" field.
func (m *PlaybackClientMutation) ResetIsBuffered() {
	m.is_buffered = nil
}

// SetSessionID sets the "session" edge to the PlaySession entity by id.
func (m *PlaybackClientMutation) SetSessionID(id int) {
	m.session = &id
}

// ClearSession clears the "session" edge to the PlaySession entity.
func (m *PlaybackClientMutation) ClearSession() {
	m.clearedsession = true
}

// SessionCleared reports if the "session" edge to the PlaySession entity was cleared.
func (m *PlaybackClientMutation) SessionCleared() bool {
	return m.clearedsession
}

// SessionID returns the "session" edge ID in the mutation.
func (m *PlaybackClientMutation) SessionID() (id int, exists bool) {
	if m.session != nil {
		return *m.session, true
	}
	return
}

// SessionIDs returns the "session" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// SessionID instead. It exists only for internal usage by the builders.
func (m *PlaybackClientMutation) SessionIDs() (ids []int) {
	if id := m.session; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetSession resets all changes to the "session" edge.
func (m *PlaybackClientMutation) ResetSession() {
	m.session = nil
	m.clearedsession = false
}

// Where appends a list predicates to the PlaybackClientMutation builder.
func (m *PlaybackClientMutation) Where(ps ...predicate.PlaybackClient) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the PlaybackClientMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *PlaybackClientMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.PlaybackClient, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *PlaybackClientMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *PlaybackClientMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (PlaybackClient).
func (m *PlaybackClientMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PlaybackClientMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.is_buffered != nil {
		fields = append(fields, playbackclient.FieldIsBuffered)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PlaybackClientMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case playbackclient.FieldIsBuffered:
		return m.IsBuffered()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PlaybackClientMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case playbackclient.FieldIsBuffered:
		return m.OldIsBuffered(ctx)
	}
	return nil, fmt.Errorf("unknown PlaybackClient field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PlaybackClientMutation) SetField(name string, value ent.Value) error {
	switch name {
	case playbackclient.FieldIsBuffered:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsBuffered(v)
		return nil
	}
	return fmt.Errorf("unknown PlaybackClient field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PlaybackClientMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PlaybackClientMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PlaybackClientMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown PlaybackClient numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PlaybackClientMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PlaybackClientMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PlaybackClientMutation) ClearField(name string) error {
	return fmt.Errorf("unknown PlaybackClient nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PlaybackClientMutation) ResetField(name string) error {
	switch name {
	case playbackclient.FieldIsBuffered:
		m.ResetIsBuffered()
		return nil
	}
	return fmt.Errorf("unknown PlaybackClient field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PlaybackClientMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.session != nil {
		edges = append(edges, playbackclient.EdgeSession)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PlaybackClientMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case playbackclient.EdgeSession:
		if id := m.session; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PlaybackClientMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PlaybackClientMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PlaybackClientMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedsession {
		edges = append(edges, playbackclient.EdgeSession)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PlaybackClientMutation) EdgeCleared(name string) bool {
	switch name {
	case playbackclient.EdgeSession:
		return m.clearedsession
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PlaybackClientMutation) ClearEdge(name string) error {
	switch name {
	case playbackclient.EdgeSession:
		m.ClearSession()
		return nil
	}
	return fmt.Errorf("unknown PlaybackClient unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PlaybackClientMutation) ResetEdge(name string) error {
	switch name {
	case playbackclient.EdgeSession:
		m.ResetSession()
		return nil
	}
	return fmt.Errorf("unknown PlaybackClient edge %s", name)
}

// StreamMutation represents an operation that mutates the Stream nodes in the graph.
type StreamMutation struct {
	config
	op                  Op
	typ                 string
	id                  *int
	width               *int
	addwidth            *int
	height              *int
	addheight           *int
	container           *string
	video_codec         *string
	audio_codec         *string
	segment_duration    *int
	addsegment_duration *int
	quality             *stream.Quality
	_type               *stream.Type
	clearedFields       map[string]struct{}
	done                bool
	oldValue            func(context.Context) (*Stream, error)
	predicates          []predicate.Stream
}

var _ ent.Mutation = (*StreamMutation)(nil)

// streamOption allows management of the mutation configuration using functional options.
type streamOption func(*StreamMutation)

// newStreamMutation creates new mutation for the Stream entity.
func newStreamMutation(c config, op Op, opts ...streamOption) *StreamMutation {
	m := &StreamMutation{
		config:        c,
		op:            op,
		typ:           TypeStream,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withStreamID sets the ID field of the mutation.
func withStreamID(id int) streamOption {
	return func(m *StreamMutation) {
		var (
			err   error
			once  sync.Once
			value *Stream
		)
		m.oldValue = func(ctx context.Context) (*Stream, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Stream.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withStream sets the old Stream of the mutation.
func withStream(node *Stream) streamOption {
	return func(m *StreamMutation) {
		m.oldValue = func(context.Context) (*Stream, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m StreamMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m StreamMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *StreamMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *StreamMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Stream.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetWidth sets the "width" field.
func (m *StreamMutation) SetWidth(i int) {
	m.width = &i
	m.addwidth = nil
}

// Width returns the value of the "width" field in the mutation.
func (m *StreamMutation) Width() (r int, exists bool) {
	v := m.width
	if v == nil {
		return
	}
	return *v, true
}

// OldWidth returns the old "width" field's value of the Stream entity.
// If the Stream object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StreamMutation) OldWidth(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldWidth is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldWidth requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWidth: %w", err)
	}
	return oldValue.Width, nil
}

// AddWidth adds i to the "width" field.
func (m *StreamMutation) AddWidth(i int) {
	if m.addwidth != nil {
		*m.addwidth += i
	} else {
		m.addwidth = &i
	}
}

// AddedWidth returns the value that was added to the "width" field in this mutation.
func (m *StreamMutation) AddedWidth() (r int, exists bool) {
	v := m.addwidth
	if v == nil {
		return
	}
	return *v, true
}

// ResetWidth resets all changes to the "width" field.
func (m *StreamMutation) ResetWidth() {
	m.width = nil
	m.addwidth = nil
}

// SetHeight sets the "height" field.
func (m *StreamMutation) SetHeight(i int) {
	m.height = &i
	m.addheight = nil
}

// Height returns the value of the "height" field in the mutation.
func (m *StreamMutation) Height() (r int, exists bool) {
	v := m.height
	if v == nil {
		return
	}
	return *v, true
}

// OldHeight returns the old "height" field's value of the Stream entity.
// If the Stream object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StreamMutation) OldHeight(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHeight is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHeight requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHeight: %w", err)
	}
	return oldValue.Height, nil
}

// AddHeight adds i to the "height" field.
func (m *StreamMutation) AddHeight(i int) {
	if m.addheight != nil {
		*m.addheight += i
	} else {
		m.addheight = &i
	}
}

// AddedHeight returns the value that was added to the "height" field in this mutation.
func (m *StreamMutation) AddedHeight() (r int, exists bool) {
	v := m.addheight
	if v == nil {
		return
	}
	return *v, true
}

// ResetHeight resets all changes to the "height" field.
func (m *StreamMutation) ResetHeight() {
	m.height = nil
	m.addheight = nil
}

// SetContainer sets the "container" field.
func (m *StreamMutation) SetContainer(s string) {
	m.container = &s
}

// Container returns the value of the "container" field in the mutation.
func (m *StreamMutation) Container() (r string, exists bool) {
	v := m.container
	if v == nil {
		return
	}
	return *v, true
}

// OldContainer returns the old "container" field's value of the Stream entity.
// If the Stream object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StreamMutation) OldContainer(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldContainer is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldContainer requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldContainer: %w", err)
	}
	return oldValue.Container, nil
}

// ResetContainer resets all changes to the "container" field.
func (m *StreamMutation) ResetContainer() {
	m.container = nil
}

// SetVideoCodec sets the "video_codec" field.
func (m *StreamMutation) SetVideoCodec(s string) {
	m.video_codec = &s
}

// VideoCodec returns the value of the "video_codec" field in the mutation.
func (m *StreamMutation) VideoCodec() (r string, exists bool) {
	v := m.video_codec
	if v == nil {
		return
	}
	return *v, true
}

// OldVideoCodec returns the old "video_codec" field's value of the Stream entity.
// If the Stream object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StreamMutation) OldVideoCodec(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVideoCodec is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVideoCodec requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVideoCodec: %w", err)
	}
	return oldValue.VideoCodec, nil
}

// ResetVideoCodec resets all changes to the "video_codec" field.
func (m *StreamMutation) ResetVideoCodec() {
	m.video_codec = nil
}

// SetAudioCodec sets the "audio_codec" field.
func (m *StreamMutation) SetAudioCodec(s string) {
	m.audio_codec = &s
}

// AudioCodec returns the value of the "audio_codec" field in the mutation.
func (m *StreamMutation) AudioCodec() (r string, exists bool) {
	v := m.audio_codec
	if v == nil {
		return
	}
	return *v, true
}

// OldAudioCodec returns the old "audio_codec" field's value of the Stream entity.
// If the Stream object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StreamMutation) OldAudioCodec(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAudioCodec is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAudioCodec requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAudioCodec: %w", err)
	}
	return oldValue.AudioCodec, nil
}

// ResetAudioCodec resets all changes to the "audio_codec" field.
func (m *StreamMutation) ResetAudioCodec() {
	m.audio_codec = nil
}

// SetSegmentDuration sets the "segment_duration" field.
func (m *StreamMutation) SetSegmentDuration(i int) {
	m.segment_duration = &i
	m.addsegment_duration = nil
}

// SegmentDuration returns the value of the "segment_duration" field in the mutation.
func (m *StreamMutation) SegmentDuration() (r int, exists bool) {
	v := m.segment_duration
	if v == nil {
		return
	}
	return *v, true
}

// OldSegmentDuration returns the old "segment_duration" field's value of the Stream entity.
// If the Stream object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StreamMutation) OldSegmentDuration(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSegmentDuration is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSegmentDuration requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSegmentDuration: %w", err)
	}
	return oldValue.SegmentDuration, nil
}

// AddSegmentDuration adds i to the "segment_duration" field.
func (m *StreamMutation) AddSegmentDuration(i int) {
	if m.addsegment_duration != nil {
		*m.addsegment_duration += i
	} else {
		m.addsegment_duration = &i
	}
}

// AddedSegmentDuration returns the value that was added to the "segment_duration" field in this mutation.
func (m *StreamMutation) AddedSegmentDuration() (r int, exists bool) {
	v := m.addsegment_duration
	if v == nil {
		return
	}
	return *v, true
}

// ResetSegmentDuration resets all changes to the "segment_duration" field.
func (m *StreamMutation) ResetSegmentDuration() {
	m.segment_duration = nil
	m.addsegment_duration = nil
}

// SetQuality sets the "quality" field.
func (m *StreamMutation) SetQuality(s stream.Quality) {
	m.quality = &s
}

// Quality returns the value of the "quality" field in the mutation.
func (m *StreamMutation) Quality() (r stream.Quality, exists bool) {
	v := m.quality
	if v == nil {
		return
	}
	return *v, true
}

// OldQuality returns the old "quality" field's value of the Stream entity.
// If the Stream object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StreamMutation) OldQuality(ctx context.Context) (v stream.Quality, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldQuality is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldQuality requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldQuality: %w", err)
	}
	return oldValue.Quality, nil
}

// ResetQuality resets all changes to the "quality" field.
func (m *StreamMutation) ResetQuality() {
	m.quality = nil
}

// SetType sets the "type" field.
func (m *StreamMutation) SetType(s stream.Type) {
	m._type = &s
}

// GetType returns the value of the "type" field in the mutation.
func (m *StreamMutation) GetType() (r stream.Type, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the Stream entity.
// If the Stream object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StreamMutation) OldType(ctx context.Context) (v stream.Type, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *StreamMutation) ResetType() {
	m._type = nil
}

// Where appends a list predicates to the StreamMutation builder.
func (m *StreamMutation) Where(ps ...predicate.Stream) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the StreamMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *StreamMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Stream, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *StreamMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *StreamMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Stream).
func (m *StreamMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *StreamMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.width != nil {
		fields = append(fields, stream.FieldWidth)
	}
	if m.height != nil {
		fields = append(fields, stream.FieldHeight)
	}
	if m.container != nil {
		fields = append(fields, stream.FieldContainer)
	}
	if m.video_codec != nil {
		fields = append(fields, stream.FieldVideoCodec)
	}
	if m.audio_codec != nil {
		fields = append(fields, stream.FieldAudioCodec)
	}
	if m.segment_duration != nil {
		fields = append(fields, stream.FieldSegmentDuration)
	}
	if m.quality != nil {
		fields = append(fields, stream.FieldQuality)
	}
	if m._type != nil {
		fields = append(fields, stream.FieldType)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *StreamMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case stream.FieldWidth:
		return m.Width()
	case stream.FieldHeight:
		return m.Height()
	case stream.FieldContainer:
		return m.Container()
	case stream.FieldVideoCodec:
		return m.VideoCodec()
	case stream.FieldAudioCodec:
		return m.AudioCodec()
	case stream.FieldSegmentDuration:
		return m.SegmentDuration()
	case stream.FieldQuality:
		return m.Quality()
	case stream.FieldType:
		return m.GetType()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *StreamMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case stream.FieldWidth:
		return m.OldWidth(ctx)
	case stream.FieldHeight:
		return m.OldHeight(ctx)
	case stream.FieldContainer:
		return m.OldContainer(ctx)
	case stream.FieldVideoCodec:
		return m.OldVideoCodec(ctx)
	case stream.FieldAudioCodec:
		return m.OldAudioCodec(ctx)
	case stream.FieldSegmentDuration:
		return m.OldSegmentDuration(ctx)
	case stream.FieldQuality:
		return m.OldQuality(ctx)
	case stream.FieldType:
		return m.OldType(ctx)
	}
	return nil, fmt.Errorf("unknown Stream field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *StreamMutation) SetField(name string, value ent.Value) error {
	switch name {
	case stream.FieldWidth:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWidth(v)
		return nil
	case stream.FieldHeight:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHeight(v)
		return nil
	case stream.FieldContainer:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetContainer(v)
		return nil
	case stream.FieldVideoCodec:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVideoCodec(v)
		return nil
	case stream.FieldAudioCodec:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAudioCodec(v)
		return nil
	case stream.FieldSegmentDuration:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSegmentDuration(v)
		return nil
	case stream.FieldQuality:
		v, ok := value.(stream.Quality)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetQuality(v)
		return nil
	case stream.FieldType:
		v, ok := value.(stream.Type)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	}
	return fmt.Errorf("unknown Stream field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *StreamMutation) AddedFields() []string {
	var fields []string
	if m.addwidth != nil {
		fields = append(fields, stream.FieldWidth)
	}
	if m.addheight != nil {
		fields = append(fields, stream.FieldHeight)
	}
	if m.addsegment_duration != nil {
		fields = append(fields, stream.FieldSegmentDuration)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *StreamMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case stream.FieldWidth:
		return m.AddedWidth()
	case stream.FieldHeight:
		return m.AddedHeight()
	case stream.FieldSegmentDuration:
		return m.AddedSegmentDuration()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *StreamMutation) AddField(name string, value ent.Value) error {
	switch name {
	case stream.FieldWidth:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddWidth(v)
		return nil
	case stream.FieldHeight:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddHeight(v)
		return nil
	case stream.FieldSegmentDuration:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSegmentDuration(v)
		return nil
	}
	return fmt.Errorf("unknown Stream numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *StreamMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *StreamMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *StreamMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Stream nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *StreamMutation) ResetField(name string) error {
	switch name {
	case stream.FieldWidth:
		m.ResetWidth()
		return nil
	case stream.FieldHeight:
		m.ResetHeight()
		return nil
	case stream.FieldContainer:
		m.ResetContainer()
		return nil
	case stream.FieldVideoCodec:
		m.ResetVideoCodec()
		return nil
	case stream.FieldAudioCodec:
		m.ResetAudioCodec()
		return nil
	case stream.FieldSegmentDuration:
		m.ResetSegmentDuration()
		return nil
	case stream.FieldQuality:
		m.ResetQuality()
		return nil
	case stream.FieldType:
		m.ResetType()
		return nil
	}
	return fmt.Errorf("unknown Stream field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *StreamMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *StreamMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *StreamMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *StreamMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *StreamMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *StreamMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *StreamMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Stream unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *StreamMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Stream edge %s", name)
}

// VideoMutation represents an operation that mutates the Video nodes in the graph.
type VideoMutation struct {
	config
	op                         Op
	typ                        string
	id                         *int
	_path                      *string
	created_at                 *time.Time
	clearedFields              map[string]struct{}
	play_session_medias        map[int]struct{}
	removedplay_session_medias map[int]struct{}
	clearedplay_session_medias bool
	library                    *int
	clearedlibrary             bool
	done                       bool
	oldValue                   func(context.Context) (*Video, error)
	predicates                 []predicate.Video
}

var _ ent.Mutation = (*VideoMutation)(nil)

// videoOption allows management of the mutation configuration using functional options.
type videoOption func(*VideoMutation)

// newVideoMutation creates new mutation for the Video entity.
func newVideoMutation(c config, op Op, opts ...videoOption) *VideoMutation {
	m := &VideoMutation{
		config:        c,
		op:            op,
		typ:           TypeVideo,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withVideoID sets the ID field of the mutation.
func withVideoID(id int) videoOption {
	return func(m *VideoMutation) {
		var (
			err   error
			once  sync.Once
			value *Video
		)
		m.oldValue = func(ctx context.Context) (*Video, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Video.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withVideo sets the old Video of the mutation.
func withVideo(node *Video) videoOption {
	return func(m *VideoMutation) {
		m.oldValue = func(context.Context) (*Video, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m VideoMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m VideoMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *VideoMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *VideoMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Video.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetPath sets the "path" field.
func (m *VideoMutation) SetPath(s string) {
	m._path = &s
}

// Path returns the value of the "path" field in the mutation.
func (m *VideoMutation) Path() (r string, exists bool) {
	v := m._path
	if v == nil {
		return
	}
	return *v, true
}

// OldPath returns the old "path" field's value of the Video entity.
// If the Video object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VideoMutation) OldPath(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPath is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPath requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPath: %w", err)
	}
	return oldValue.Path, nil
}

// ResetPath resets all changes to the "path" field.
func (m *VideoMutation) ResetPath() {
	m._path = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *VideoMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *VideoMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Video entity.
// If the Video object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VideoMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *VideoMutation) ResetCreatedAt() {
	m.created_at = nil
}

// AddPlaySessionMediaIDs adds the "play_session_medias" edge to the PlaySessionMedia entity by ids.
func (m *VideoMutation) AddPlaySessionMediaIDs(ids ...int) {
	if m.play_session_medias == nil {
		m.play_session_medias = make(map[int]struct{})
	}
	for i := range ids {
		m.play_session_medias[ids[i]] = struct{}{}
	}
}

// ClearPlaySessionMedias clears the "play_session_medias" edge to the PlaySessionMedia entity.
func (m *VideoMutation) ClearPlaySessionMedias() {
	m.clearedplay_session_medias = true
}

// PlaySessionMediasCleared reports if the "play_session_medias" edge to the PlaySessionMedia entity was cleared.
func (m *VideoMutation) PlaySessionMediasCleared() bool {
	return m.clearedplay_session_medias
}

// RemovePlaySessionMediaIDs removes the "play_session_medias" edge to the PlaySessionMedia entity by IDs.
func (m *VideoMutation) RemovePlaySessionMediaIDs(ids ...int) {
	if m.removedplay_session_medias == nil {
		m.removedplay_session_medias = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.play_session_medias, ids[i])
		m.removedplay_session_medias[ids[i]] = struct{}{}
	}
}

// RemovedPlaySessionMedias returns the removed IDs of the "play_session_medias" edge to the PlaySessionMedia entity.
func (m *VideoMutation) RemovedPlaySessionMediasIDs() (ids []int) {
	for id := range m.removedplay_session_medias {
		ids = append(ids, id)
	}
	return
}

// PlaySessionMediasIDs returns the "play_session_medias" edge IDs in the mutation.
func (m *VideoMutation) PlaySessionMediasIDs() (ids []int) {
	for id := range m.play_session_medias {
		ids = append(ids, id)
	}
	return
}

// ResetPlaySessionMedias resets all changes to the "play_session_medias" edge.
func (m *VideoMutation) ResetPlaySessionMedias() {
	m.play_session_medias = nil
	m.clearedplay_session_medias = false
	m.removedplay_session_medias = nil
}

// SetLibraryID sets the "library" edge to the Library entity by id.
func (m *VideoMutation) SetLibraryID(id int) {
	m.library = &id
}

// ClearLibrary clears the "library" edge to the Library entity.
func (m *VideoMutation) ClearLibrary() {
	m.clearedlibrary = true
}

// LibraryCleared reports if the "library" edge to the Library entity was cleared.
func (m *VideoMutation) LibraryCleared() bool {
	return m.clearedlibrary
}

// LibraryID returns the "library" edge ID in the mutation.
func (m *VideoMutation) LibraryID() (id int, exists bool) {
	if m.library != nil {
		return *m.library, true
	}
	return
}

// LibraryIDs returns the "library" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// LibraryID instead. It exists only for internal usage by the builders.
func (m *VideoMutation) LibraryIDs() (ids []int) {
	if id := m.library; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetLibrary resets all changes to the "library" edge.
func (m *VideoMutation) ResetLibrary() {
	m.library = nil
	m.clearedlibrary = false
}

// Where appends a list predicates to the VideoMutation builder.
func (m *VideoMutation) Where(ps ...predicate.Video) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the VideoMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *VideoMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Video, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *VideoMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *VideoMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Video).
func (m *VideoMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *VideoMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m._path != nil {
		fields = append(fields, video.FieldPath)
	}
	if m.created_at != nil {
		fields = append(fields, video.FieldCreatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *VideoMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case video.FieldPath:
		return m.Path()
	case video.FieldCreatedAt:
		return m.CreatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *VideoMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case video.FieldPath:
		return m.OldPath(ctx)
	case video.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Video field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *VideoMutation) SetField(name string, value ent.Value) error {
	switch name {
	case video.FieldPath:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPath(v)
		return nil
	case video.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Video field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *VideoMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *VideoMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *VideoMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Video numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *VideoMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *VideoMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *VideoMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Video nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *VideoMutation) ResetField(name string) error {
	switch name {
	case video.FieldPath:
		m.ResetPath()
		return nil
	case video.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	}
	return fmt.Errorf("unknown Video field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *VideoMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.play_session_medias != nil {
		edges = append(edges, video.EdgePlaySessionMedias)
	}
	if m.library != nil {
		edges = append(edges, video.EdgeLibrary)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *VideoMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case video.EdgePlaySessionMedias:
		ids := make([]ent.Value, 0, len(m.play_session_medias))
		for id := range m.play_session_medias {
			ids = append(ids, id)
		}
		return ids
	case video.EdgeLibrary:
		if id := m.library; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *VideoMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedplay_session_medias != nil {
		edges = append(edges, video.EdgePlaySessionMedias)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *VideoMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case video.EdgePlaySessionMedias:
		ids := make([]ent.Value, 0, len(m.removedplay_session_medias))
		for id := range m.removedplay_session_medias {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *VideoMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedplay_session_medias {
		edges = append(edges, video.EdgePlaySessionMedias)
	}
	if m.clearedlibrary {
		edges = append(edges, video.EdgeLibrary)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *VideoMutation) EdgeCleared(name string) bool {
	switch name {
	case video.EdgePlaySessionMedias:
		return m.clearedplay_session_medias
	case video.EdgeLibrary:
		return m.clearedlibrary
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *VideoMutation) ClearEdge(name string) error {
	switch name {
	case video.EdgeLibrary:
		m.ClearLibrary()
		return nil
	}
	return fmt.Errorf("unknown Video unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *VideoMutation) ResetEdge(name string) error {
	switch name {
	case video.EdgePlaySessionMedias:
		m.ResetPlaySessionMedias()
		return nil
	case video.EdgeLibrary:
		m.ResetLibrary()
		return nil
	}
	return fmt.Errorf("unknown Video edge %s", name)
}

// VideoCodecMutation represents an operation that mutates the VideoCodec nodes in the graph.
type VideoCodecMutation struct {
	config
	op            Op
	typ           string
	id            *int
	name          *string
	mime          *string
	dynamic_range *videocodec.DynamicRange
	clearedFields map[string]struct{}
	media         *int
	clearedmedia  bool
	done          bool
	oldValue      func(context.Context) (*VideoCodec, error)
	predicates    []predicate.VideoCodec
}

var _ ent.Mutation = (*VideoCodecMutation)(nil)

// videocodecOption allows management of the mutation configuration using functional options.
type videocodecOption func(*VideoCodecMutation)

// newVideoCodecMutation creates new mutation for the VideoCodec entity.
func newVideoCodecMutation(c config, op Op, opts ...videocodecOption) *VideoCodecMutation {
	m := &VideoCodecMutation{
		config:        c,
		op:            op,
		typ:           TypeVideoCodec,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withVideoCodecID sets the ID field of the mutation.
func withVideoCodecID(id int) videocodecOption {
	return func(m *VideoCodecMutation) {
		var (
			err   error
			once  sync.Once
			value *VideoCodec
		)
		m.oldValue = func(ctx context.Context) (*VideoCodec, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().VideoCodec.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withVideoCodec sets the old VideoCodec of the mutation.
func withVideoCodec(node *VideoCodec) videocodecOption {
	return func(m *VideoCodecMutation) {
		m.oldValue = func(context.Context) (*VideoCodec, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m VideoCodecMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m VideoCodecMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *VideoCodecMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *VideoCodecMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().VideoCodec.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *VideoCodecMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *VideoCodecMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the VideoCodec entity.
// If the VideoCodec object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VideoCodecMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *VideoCodecMutation) ResetName() {
	m.name = nil
}

// SetMime sets the "mime" field.
func (m *VideoCodecMutation) SetMime(s string) {
	m.mime = &s
}

// Mime returns the value of the "mime" field in the mutation.
func (m *VideoCodecMutation) Mime() (r string, exists bool) {
	v := m.mime
	if v == nil {
		return
	}
	return *v, true
}

// OldMime returns the old "mime" field's value of the VideoCodec entity.
// If the VideoCodec object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VideoCodecMutation) OldMime(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMime: %w", err)
	}
	return oldValue.Mime, nil
}

// ResetMime resets all changes to the "mime" field.
func (m *VideoCodecMutation) ResetMime() {
	m.mime = nil
}

// SetDynamicRange sets the "dynamic_range" field.
func (m *VideoCodecMutation) SetDynamicRange(vr videocodec.DynamicRange) {
	m.dynamic_range = &vr
}

// DynamicRange returns the value of the "dynamic_range" field in the mutation.
func (m *VideoCodecMutation) DynamicRange() (r videocodec.DynamicRange, exists bool) {
	v := m.dynamic_range
	if v == nil {
		return
	}
	return *v, true
}

// OldDynamicRange returns the old "dynamic_range" field's value of the VideoCodec entity.
// If the VideoCodec object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VideoCodecMutation) OldDynamicRange(ctx context.Context) (v videocodec.DynamicRange, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDynamicRange is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDynamicRange requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDynamicRange: %w", err)
	}
	return oldValue.DynamicRange, nil
}

// ResetDynamicRange resets all changes to the "dynamic_range" field.
func (m *VideoCodecMutation) ResetDynamicRange() {
	m.dynamic_range = nil
}

// SetMediaID sets the "media" edge to the PlaySessionMedia entity by id.
func (m *VideoCodecMutation) SetMediaID(id int) {
	m.media = &id
}

// ClearMedia clears the "media" edge to the PlaySessionMedia entity.
func (m *VideoCodecMutation) ClearMedia() {
	m.clearedmedia = true
}

// MediaCleared reports if the "media" edge to the PlaySessionMedia entity was cleared.
func (m *VideoCodecMutation) MediaCleared() bool {
	return m.clearedmedia
}

// MediaID returns the "media" edge ID in the mutation.
func (m *VideoCodecMutation) MediaID() (id int, exists bool) {
	if m.media != nil {
		return *m.media, true
	}
	return
}

// MediaIDs returns the "media" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// MediaID instead. It exists only for internal usage by the builders.
func (m *VideoCodecMutation) MediaIDs() (ids []int) {
	if id := m.media; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetMedia resets all changes to the "media" edge.
func (m *VideoCodecMutation) ResetMedia() {
	m.media = nil
	m.clearedmedia = false
}

// Where appends a list predicates to the VideoCodecMutation builder.
func (m *VideoCodecMutation) Where(ps ...predicate.VideoCodec) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the VideoCodecMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *VideoCodecMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.VideoCodec, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *VideoCodecMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *VideoCodecMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (VideoCodec).
func (m *VideoCodecMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *VideoCodecMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.name != nil {
		fields = append(fields, videocodec.FieldName)
	}
	if m.mime != nil {
		fields = append(fields, videocodec.FieldMime)
	}
	if m.dynamic_range != nil {
		fields = append(fields, videocodec.FieldDynamicRange)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *VideoCodecMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case videocodec.FieldName:
		return m.Name()
	case videocodec.FieldMime:
		return m.Mime()
	case videocodec.FieldDynamicRange:
		return m.DynamicRange()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *VideoCodecMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case videocodec.FieldName:
		return m.OldName(ctx)
	case videocodec.FieldMime:
		return m.OldMime(ctx)
	case videocodec.FieldDynamicRange:
		return m.OldDynamicRange(ctx)
	}
	return nil, fmt.Errorf("unknown VideoCodec field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *VideoCodecMutation) SetField(name string, value ent.Value) error {
	switch name {
	case videocodec.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case videocodec.FieldMime:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMime(v)
		return nil
	case videocodec.FieldDynamicRange:
		v, ok := value.(videocodec.DynamicRange)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDynamicRange(v)
		return nil
	}
	return fmt.Errorf("unknown VideoCodec field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *VideoCodecMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *VideoCodecMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *VideoCodecMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown VideoCodec numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *VideoCodecMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *VideoCodecMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *VideoCodecMutation) ClearField(name string) error {
	return fmt.Errorf("unknown VideoCodec nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *VideoCodecMutation) ResetField(name string) error {
	switch name {
	case videocodec.FieldName:
		m.ResetName()
		return nil
	case videocodec.FieldMime:
		m.ResetMime()
		return nil
	case videocodec.FieldDynamicRange:
		m.ResetDynamicRange()
		return nil
	}
	return fmt.Errorf("unknown VideoCodec field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *VideoCodecMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.media != nil {
		edges = append(edges, videocodec.EdgeMedia)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *VideoCodecMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case videocodec.EdgeMedia:
		if id := m.media; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *VideoCodecMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *VideoCodecMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *VideoCodecMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedmedia {
		edges = append(edges, videocodec.EdgeMedia)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *VideoCodecMutation) EdgeCleared(name string) bool {
	switch name {
	case videocodec.EdgeMedia:
		return m.clearedmedia
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *VideoCodecMutation) ClearEdge(name string) error {
	switch name {
	case videocodec.EdgeMedia:
		m.ClearMedia()
		return nil
	}
	return fmt.Errorf("unknown VideoCodec unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *VideoCodecMutation) ResetEdge(name string) error {
	switch name {
	case videocodec.EdgeMedia:
		m.ResetMedia()
		return nil
	}
	return fmt.Errorf("unknown VideoCodec edge %s", name)
}
